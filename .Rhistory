view(mtcars)
View(mtcars)
pesq[altura<1.6,]
pesq = cbind(pesquisa, olhos)
pais = c('Portugal', 'Inglaterra', 'Irlanda', 'Egito', 'Brasil')
nome = c('Bruno','Tiago', 'Amanda', 'Bianca', ' Marta')
altura = c(1.66, 1.88, 1.76, 1.67, 1.98)
codigo = c(5001, 2183, 4702, 8890, 7965)
pesquisa = data.frame(pais, nome, altura, codigo)
pesq = cbind(pesquisa, olhos)
#add a um dataframe ja existente
olhos = c('verde', 'castanho', 'verde', 'azul', 'castanho')
pesq = cbind(pesquisa, olhos)
(pesq)
#Obtendo um vetor de um dataframe
pesq$pais
head(pesq)
pesq[altura<1.6,]
pesq[altura<1.60,]
pacientes<-data.frame(read.csv(file='paciente.csv', header = TRUE, sep = ","))
getwd
getwd()
setwd("C:/DSA/RAzureMachineLearning/CursoR/DSA.SV.RAzureML.Cap02")
pacientes<-data.frame(read.csv(file='paciente.csv', header = TRUE, sep = ","))
pacientes<-data.frame(read.csv(file='pacientes.csv', header = TRUE, sep = ","))
#visualizando o dataset
view(pacientes)
#visualizando o dataset
view(pacientes)
#visualizando o dataset
View(pacientes)
head(pacientes)
summary(pacientes)
# Exercício 1 - Crie um vetor com 30 números inteiros
vet = c(1:30)
vet
# Exercício 2 - Crie uma matriz com 4 linhas e 4 colunas preenchida com números inteiros
mat = matrix(1:16, nr = 4, nc= 4)
mat# Exercício 3 - Crie uma lista unindo o vetor e matriz criados anteriormente
# Exercício 3 - Crie uma lista unindo o vetor e matriz criados anteriormente
lista1 = list(vet, mat)
lista1
class(lista1)
# Exercício 4 - Usando a função read.table() leia o arquivo do link abaixo para uma dataframe
# http://data.princeton.edu/wws509/datasets/effort.dat
df1=data.frame(read.table('http://data.princeton.edu/wws509/datasets/effort.dat'))
df1
# Exercício 5 - Transforme o dataframe anterior, em um dataframe nomeado com os seguintes labels:
# c("config", "esfc", "chang")
rownames(df1)<-c('config','esfc','chang')
# Exercício 5 - Transforme o dataframe anterior, em um dataframe nomeado com os seguintes labels:
# c("config", "esfc", "chang")
colnames(df1)<-c('config','esfc','chang')
df1
# Exercício 6 - Imprima na tela o dataframe iris, verifique quantas dimensões existem no dataframe iris e imprima um resumo do dataset
iris
dim(iris)
summary(iris)
plot(iris$Sepal.Length,iris$Sepal.Width)
# Exercício 8 - Usando a função subset, crie um novo dataframe com o conjunto de dados do dataframe iris em que Sepal.Length > 7
# Dica: consulte o help para aprender como usar a função subset()
?subset
irisfiltro=subset(iris, sepal.length>7)
irisfiltro=subset(iris, iris.sepal.length>7)
irisfiltro=subset(iris, iris.Sepal.Length>7)
irisfiltro=subset(iris, iris$Sepal.Length>7)
install.packages("dplyr")
# Exercícios 9 (Desafio) - Crie um dataframe que seja cópia do dataframe iris e usando a função slice(), divida o dataframe em um subset de 15 linhas
# Dica 1: Você vai ter que instalar e carregar o pacote dplyr
# Dica 2: Consulte o help para aprender como usar a função slice()
?slice
# Exercícios 9 (Desafio) - Crie um dataframe que seja cópia do dataframe iris e usando a função slice(), divida o dataframe em um subset de 15 linhas
# Dica 1: Você vai ter que instalar e carregar o pacote dplyr
# Dica 2: Consulte o help para aprender como usar a função slice()
?slice
# Exercícios 9 (Desafio) - Crie um dataframe que seja cópia do dataframe iris e usando a função slice(), divida o dataframe em um subset de 15 linhas
# Dica 1: Você vai ter que instalar e carregar o pacote dplyr
# Dica 2: Consulte o help para aprender como usar a função slice()
??slice
library(dplyr)
# Exercícios 9 (Desafio) - Crie um dataframe que seja cópia do dataframe iris e usando a função slice(), divida o dataframe em um subset de 15 linhas
# Dica 1: Você vai ter que instalar e carregar o pacote dplyr
# Dica 2: Consulte o help para aprender como usar a função slice()
sub1=slice(iris, 15)
sub1
# Exercícios 9 (Desafio) - Crie um dataframe que seja cópia do dataframe iris e usando a função slice(), divida o dataframe em um subset de 15 linhas
# Dica 1: Você vai ter que instalar e carregar o pacote dplyr
# Dica 2: Consulte o help para aprender como usar a função slice()
sub1=slice(iris, 1:15)
sub1
?filter
filter(sub1, Sepal.Length > 6 )
filter(sub1, Sepal.Length > 5 )
filter(sub1, Sepal.Length > 6 )
setwd("C:/DSA/RAzureMachineLearning/CursoR/DSA.SV.RAzureML.Cap03")
vec1 <- c("Macho","Femea","Femea","Macho","Macho")
vec1
fac_vec1 <- factor(vec1)
fac_vec1
class(vec1)
class(fac_vec1)
# Variáveis categóricas nominais
# Não existe uma ordem implícita
animais <- c("Zebra", "Pantera", "Rinoceronte", "Macaco", "Tigre")
animais
fac_animais <- factor(animais)
fac_animais
class(fac_animais)
levels(fac_animais)
# Variáveis categóricas ordinais
# Possuem uma ordem natural
grad <- c("Mestrado", "Doutorado", "Bacharelado", "Mestrado", "Mestrado")
fac_grad <- factor(grad, order = TRUE, levels = c("Doutorado", "Mestrado", "Bacharelado"))
fac_grad
levels(fac_grad)
summary(fac_grad)
vec2 <- c("M", "F", "F", "M", "M", "M", "F", "F", "M", "M", "M", "F", "F", "M", "M")
vec2
fac_vec2 <- factor(vec2)
fac_vec2
levels(fac_vec2) <- c("Femea", "Macho")
fac_vec2
summary(fac_vec2)
summary(vec2)
# Mais exemplos
data = c(1,2,2,3,1,2,3,3,1,2,3,3,1)
fdata = factor(data)
fdata
rdata = factor(data, labels=c('I','II','III'))
rdata
# Fatores Não-Ordenados
set1 <- c("AA", "B", "BA", "CC", "CA", "AA", "BA", "CC", "CC")
set1
# Transformando os dados.
# R apenas criou os níveis, o que não significa que exista uma hierarquia.
f.set1 <- factor(set1)
class(f.set1)
is.ordered(f.set1)
# Fatores Ordenados
o.set1 <- factor(set1,
levels = c("CA", "BA", "AA", "CC", "B"),
ordered = TRUE)
# Fatores Ordenados
o.set1 <- factor(set1,
levels = c("CA", "BA", "AA", "CC", "B"),
ordered = TRUE)
o.set1
is.ordered(o.set1)
as.numeric(o.set1)
table(o.set1)
df <- read.csv2("etnias.csv", sep = ',')
View(df)
str(df)
# Plot
# Agora se fizermos um plot, temos um boxplot para estas variáveis categóricas
plot(df$Idade~df$Etnia, xlab = 'Etnia', ylab = 'Idade', main = 'Idade por Etnia')
# Regressão
summary(lm(Idade~Etnia, data = df))
# Níveis dos fatores
# Internamente, o R armazena valores inteiros e faz um mapeamento para as strings (em ordem alfabética)
# e agrupa as estatísticas por níveis. Agora, se fizermos sumarização de estatísticas, é possível visualizar
# a contabilização para cada categoria
levels(df$Etnia)
summary(df$Etnia)
# Regressão
summary(lm(Idade~Etnia, data = df))
# Criando vetores
vec1 <- c(1001, 1002, 1003, 1004, 1005)
getwd()
vec2 <- c(0, 1, 1, 0, 2)
vec3 <- c('Verde','Laranja','Azul','Laranja','Verde')
df <- data.frame(vec1, vec2, vec3)
# Unindo os vetores em um dataframe
df
# Verificando que o R categorizou a última coluna como fator
str(df)
# Verificando os níveis do fator. Perceba que os níveis estão categorizados em ordem alfabética
levels(df$vec3)
df$cat1 <- factor(df$vec3, labels = c("cor2", "cor1", "cor3"))
df
getwd()
x = 25
if(x<30)
{'Numero menor que 30'}
# Else
if (x < 7) {
"Este número é menor que 7"
} else {
"Este número não é menor que 7"
}
if (x < 7) {
"Este número é menor que 7"
} else if(x == 7) {
"Este é o número 7"
}else{
"Este número não é menor que 7"
}
x = 7
if (x < 7) {
"Este número é menor que 7"
} else if(x == 7) {
"Este é o número 7"
}else{
"Este número não é menor que 7"
}
x = 5
ifelse (x < 6, "Correto!", NA)
x = 9
ifelse (x < 6, "Correto!", NA)
x = c(7,5,4)
ifelse(x < 5, "Menor que 5",
ifelse(x == 5, "Igual a 5", "Maior que 5"))
# Estruturas if dentro de funções
func1 <- function(x,y){
ifelse(y < 7, x + y, "Não encontrado")
}
# Estruturas if dentro de funções
func1 <- function(x,y){
ifelse(y < 7, x + y, "Não encontrado")
}
func1(4,2)
func1(40,7)
# Rep
rep(rnorm(10), 5)
print(x)}
# Repeat
x = 1
print(x)}
repeat {
x = x + 3
if (x > 99)
break
print(x)}
# Loop For
for (i in 1:20) {print(i)}
for (q in rnorm(10)) {print(q)}
print (i)}
for(i in 1:22){
if(i == 13 | i == 15)
next
print (i)}
# O loop while não será executado
y = 6
while(y < 5){
y = y+10
print(y)
}
y = 6
while(y < 5){
y = y+10
print(y)
}
while(y < 5){
y = y+10
print(y)
}
